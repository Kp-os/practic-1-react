# Звіт з Лабораторної роботи №3

**Посилання на розгорнуту версію:** https://[ВАШ_НІК].github.io/practic-1-react/

## Фрагмент коду з логікою роботи пошуку та фільтрації
\`\`\`jsx
const [searchTerm, setSearchTerm] = useState('');
const [activeCategory, setActiveCategory] = useState('All');

const filteredPosts = postsData.filter(post => {
const matchesSearch = post.content.toLowerCase().includes(searchTerm.toLowerCase()) ||
post.author.toLowerCase().includes(searchTerm.toLowerCase());
const matchesCategory = activeCategory === 'All' || post.category === activeCategory;

return matchesSearch && matchesCategory;
});
\`\`\`

## Пояснення обробки "порожнього результату"
Обробка порожнього стану реалізована за допомогою тернарного оператора в JSX. Ми перевіряємо довжину відфільтрованого масиву `filteredPosts.length > 0`. Якщо умова істинна (є пости), ми рендеримо масив через `.map()`. Якщо хибна (масив порожній), відображається альтернативний `<p>` тег з повідомленням "Нічого не знайдено...".

## Відповіді на контрольні запитання

1. **Що таке "підняття стану" (lifting state up) і чому ми використовуємо його для SearchBar?**
   Підняття стану — це переміщення стану в найближчий спільний батьківський компонент. Ми підняли `searchTerm` у компонент `App`, оскільки це значення потрібне як для `SearchBar` (щоб відображати введений текст), так і для самого `App` (щоб фільтрувати масив `postsData` перед рендерингом).
2. **Поясніть асинхронну природу оновлення стану в useState.**
   Виклик функції встановлення стану (напр., `setSearchTerm`) не змінює змінну стану миттєво в поточному рендері. React "групує" (batches) оновлення стану для оптимізації продуктивності і застосовує їх під час наступного рендеру компонента.
3. **Чому для фільтрації ми створюємо нову змінну filteredPosts, а не змінюємо оригінальний масив postsData у стані?**
   Зміна оригінального масиву (мутація) призведе до незворотної втрати даних (ми не зможемо повернутися до відображення всіх постів, якщо очистимо поле пошуку). Створення нової змінної `filteredPosts` при кожному рендері зберігає "джерело істини" (`postsData`) недоторканим і відповідає принципу імутабельності React.
4. **У чому перевага використання керованих компонентів над некерованими при реалізації пошуку?**
   У керованому компоненті стан React є "єдиним джерелом істини". Це дозволяє миттєво реагувати на введення користувача (наприклад, фільтрувати список при кожному натисканні клавіші), легко очищати поле з коду та валідувати вхідні дані до їх відображення.